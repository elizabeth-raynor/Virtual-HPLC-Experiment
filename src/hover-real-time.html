<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>real time HOVER</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.js"></script>
    <link rel="stylesheet" href="add-solvent.css">
    <script src="app.js"></script>
</head>

<body>
    <div class="topNav text">
        <a style= "font-size: 130%; ">CHEM230L: Drug Doping Lab</a>
    </div>
    <div class="flex-container" style="flex-direction: row; justify-content: space-between; margin:1%; margin-bottom: 0;" >
        <button class="Arrow" style="background-color: #08A696; transform: rotate(270deg); width: 3vw; height: 3vw;"></button>
        <h1 class="header text" style="font-weight: bold; color: #096073; font-size: 180%;">Case 1 Chromatogram</h1>
        <button class="Download"></button>
    </div>
    <h4 class="text" style="font-size: 80%; margin: .7%;">Tip: Hover over each peak to show its area and width of the base.</h4>
    <div id="Hover-Info" class="text" style="font-size: 80%; margin: .7%;"></div>
    <div class="chart-container">
        <canvas id="chrom" width="800" height="400" margin="auto" display="block"></canvas>
        <!--<canvas id="chromText" width="200", height="100", margin="auto", display="block"></canvas>-->
    </div>

    
    <script>
    /*
    chartChrom('../data/DopingLab_dev/Case1/Chrom3.csv');
    var dict = {};
    const realTimeX = [];
    const realTimeY = [];
    var hoverMode = false;
    var maxY = 0;

    const ctx = document.getElementById('chrom').getContext('2d');

    async function getChromData(path){
        const response = await fetch(path);
        var data = await response.text();
        data = data.trim();
        //console.log(data);

        const rows = data.split('\n');
        //console.log(rows);
        rows.forEach(elt => {
            const row = elt.split(',');
            //console.log(row);
            dict[row[0]] = row[1];
            const time = parseFloat(row[0]);
            realTimeX.push(time);
            const signal = parseFloat(row[1]);
            realTimeY.push(signal);
            //console.log(time,signal);
        });
        //console.log(dict);
        maxY = getMaxY();
        maxY = Math.ceil(maxY/1000)*1000;
    }

    function getMaxY() {
        realTimeYNum = [];
        realTimeY.forEach(number => {
            var num = Number(number)
            if (!isNaN(num)) {
                realTimeYNum.push(num);
            }
        });
        //realTimeY.forEach(number => console.log(typeof(number)));
        return Math.max.apply(Math, realTimeYNum);
    }

    async function chartChrom(path){
        await getChromData(path);
    var myChart = new Chart(ctx, {
        type: 'line',
        data: {
            // change this to make it draw a data set instead of just y value
            labels: [],
            datasets: [{
                label: 'Signal(arb. units)',
                data: [],
                backgroundColor: 
                'rgba(163, 216, 108, 0.5)',
                radius: 1.5
            }],
        },
        options: {
            legend: {
                display: false
            },
            responsive: false,
            scales: {
                xAxes: [{
                    ticks: {
                    max: 10,
                    min: 0,
                    maxTicksLimit: 40,
                    },
                    scaleLabel: {
                        display: true,
                        labelString: 'Retention Time (min)'
                    }
                }],
                yAxes: [{
                    ticks: {
                    max: maxY,
                    min: 0,
                    maxTicksLimit: 11,
                    },
                    scaleLabel: {
                        display: true,
                        labelString: 'Signal (arb. units)'
                    }
                }],
            },
            hover: {
                onHover: function(elements) {
                    getCursorPosition(elements);
                }
            },
            tooltips: {
                
            }
        }
    });
        hoverMode = false;
        var i;
        for(i=0; i < realTimeX.length; i++){
            //await sleep(realTimeX[i]*0);
            addData(myChart,realTimeX[i],realTimeY[i]);
        }
        hoverMode = true;  
    }

    function addData(chart, label, data) {
        chart.data.labels.push(label);
        chart.data.datasets.forEach((dataset) => {
            dataset.data.push(data);
        });
        chart.update();
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    function getCursorPosition(event) { 
        const canvas = document.getElementById('chrom');
        let rect = canvas.getBoundingClientRect(); 
        let x = event.clientX - rect.left; 
        let y = event.clientY - rect.top; 
        
        //Convert x on cavas to x value in the data set
        var xCoord = ((x-57)/(795-57))*10
        console.log();
        var xData = (Math.ceil(xCoord*200)/200).toFixed(2)
        //console.log("Data x: " + xData);
        // Convert y on canvas to y value on the graph
        var yCoord = (((331-y))/(331))*maxY;
        if (yCoord < dict[xData]){
            console.log('inside');
            ctx.font = "50px Arial";
            ctx.fillText('label',600,75);
            //document.getElementById("Hover-Info").innerHTML="Area for Peak1<br>Width of Peak1";
            //document.getElementById("Hover-Info").style.opacity="1";
        }
        else {
            
            console.log("outside");
            //document.getElementById("Hover-Info").innerHTML="";
            //document.getElementById("Hover-Info").style.opacity="0";
        }
    } 
    let canvasElem = document.querySelector("canvas"); 
    canvasElem.addEventListener("mousedown", function(e) 
        { 
            getMousePosition(e); 
        });
    */
    </script>
</body>
</html>