<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>real time graph</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.js"></script>
    <style>
        h4{ color:#096073 }
        #text{
        position: absolute;
        top: 50%;
        left: 200px;
        font-size: 10px;
        color: #096073;
        transform: translate(-50%,-50%);
        -ms-transform: translate(-50%,-50%);
        padding: 10px;
        border-style:solid;
        border-width:5px;
        border-color:#096073;
        border-radius:5px;
        opacity: 0;
        }
            </style>
</head>

<body>
    <h1>Case 1 Real Time Graph</h1>
    <div margin="auto" max-width="1050px" padding="20" text-align="center">
        <h4>Tip: Hover over each peak to show its area and width of the base.</h4>
        <div id="text"></div>
    <canvas id="chart" width="1000" height="500" margin="auto" display="block"></canvas>
</div>
    <script>
        var fileSource = "Chrom1.csv";
        const realTimeX = [];
        const realTimeY = [];
        var hoverMode = false;

        
        const ctx = document.getElementById('chart').getContext('2d');
        var myChart = new Chart(ctx, {
            type: 'line',
            data: {
                // change this to make it draw a data set instead of just y value
                labels: [],
                datasets: [{
                    label: 'Signal(arb. units)',
                    data: [],
                    backgroundColor: 
                  'rgba(9, 96, 115, 0.5)',
                }],
            },
            options: {
                responsive: false,
                scales: {
                    xAxes: [{
                        ticks: {
                        max: 10,
                        min: 0,
                        maxTicksLimit: 40,
                        },
                        scaleLabel: {
                            display: true,
                            labelString: 'Retention Time (min)'
                        }
                    }],
                    yAxes: [{
                        ticks: {
                        max: 10000,
                        min: 0,
                        maxTicksLimit: 11,
                        },
                        scaleLabel: {
                            display: true,
                            labelString: 'Signal (arb. units)'
                        }
                    }],
                },
                
                //onClick: getCursorPosition,
                hover: {
                    // Overrides the global setting
                    enabled: true,
                    //mode: 'dataset',
                    onHover: function(elements) {
                        getCursorPosition(elements);
                    }
                }
            }
        });

        async function getData(fileSource){
            const response = await fetch(fileSource);
            const data = await response.text();
            console.log(data);

            const rows = data.split('\n');
            console.log(rows);
            rows.forEach(elt => {
                const row = elt.split(',');
                const time = parseFloat(row[0]);
                realTimeX.push(time);
                const signal = parseFloat(row[1]);
                realTimeY.push(signal);
                console.log(time,signal);
            });
        }

        async function chartIt(){
            hoverMode = false;
            await getData(fileSource);
            var i;
            for(i=0; i < realTimeX.length; i++){
                await sleep(realTimeX[i]*1);
                addData(myChart,realTimeX[i],realTimeY[i]);
            }
            hoverMode = true;  
        }

        function addData(chart, label, data) {
            chart.data.labels.push(label);
            chart.data.datasets.forEach((dataset) => {
                dataset.data.push(data);
            });
            chart.update();
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function getCursorPosition(event) {
            var i;
            if(hoverMode){
            const can = document.getElementById('chart');
            const rect = can.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            var chartX=(x-44)/95;
            var chartY=(452-y)*23.809;
                for(i=103;i<200;i++){
                    if(Math.abs(chartX-realTimeX[i])<0.05 && chartY<realTimeY[i]){
                        console.log("x: " + chartX + " y: " + chartY);
                        //alert("Area for Peak1");
                        document.getElementById("text").innerHTML="Area for Peak1<br>Width of Peak1";
                        document.getElementById("text").style.opacity="1";
                        return;
                    }
                }
                document.getElementById("text").innerHTML="";
                document.getElementById("text").style.opacity="0";
               
            }
        }


        chartIt();

    </script>

</body>
</html>